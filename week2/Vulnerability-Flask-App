import java.sql.*;
import java.util.regex.*;

/**
 * This class demonstrates common web application vulnerabilities
 * WARNING: This is UNSAFE code for educational purposes only
 */
public class VulnerableWebApp {

    // Database connection details (insecure - hardcoded credentials)
    private static final String DB_URL = "jdbc:mysql://localhost:3306/mydb";
    private static final String DB_USER = "root";
    private static final String DB_PASS = "password123";

    /**
     * 1. SQL Injection Vulnerability Example
     * @param username User input (unsanitized)
     * @param password User input (unsanitized)
     */
    public boolean loginUnsafe(String username, String password) {
        String query = "SELECT * FROM users WHERE username = '" + username + 
                      "' AND password = '" + password + "'";
        
        try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASS);
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(query)) {
            
            return rs.next(); // If any results, login "successful"
        } catch (SQLException e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 2. XSS Vulnerability Example
     * @param userInput Unsanitized user input
     * @return HTML with potential XSS
     */
    public String displayCommentUnsafe(String userInput) {
        return "<div class='comment'>" + userInput + "</div>";
    }

    /**
     * 3. Insecure Direct Object Reference
     * @param userId User-supplied ID without authorization check
     */
    public String getUserProfileUnsafe(String userId) {
        String query = "SELECT * FROM profiles WHERE user_id = " + userId;
        // ... executes query and returns sensitive data
        return "Sensitive data for user " + userId;
    }

    /**
     * 4. Command Injection Vulnerability
     * @param filename User-supplied filename
     */
    public String readFileUnsafe(String filename) {
        try {
            Process p = Runtime.getRuntime().exec("cat " + filename);
            // ... read process output
            return "File contents";
        } catch (Exception e) {
            return "Error reading file";
        }
    }

    /**
     * Secure alternatives to the vulnerable methods
     */

    // 1. SQL Injection Protection: Parameterized queries
    public boolean loginSafe(String username, String password) {
        String query = "SELECT * FROM users WHERE username = ? AND password = ?";
        
        try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASS);
             PreparedStatement stmt = conn.prepareStatement(query)) {
            
            stmt.setString(1, username);
            stmt.setString(2, password);
            ResultSet rs = stmt.executeQuery();
            
            return rs.next();
        } catch (SQLException e) {
            e.printStackTrace();
            return false;
        }
    }

    // 2. XSS Protection: Output encoding
    public String displayCommentSafe(String userInput) {
        String safeInput = userInput.replaceAll("<", "&lt;")
                                   .replaceAll(">", "&gt;")
                                   .replaceAll("\"", "&quot;")
                                   .replaceAll("'", "&#39;");
        return "<div class='comment'>" + safeInput + "</div>";
    }

    // 3. IDOR Protection: Authorization check
    public String getUserProfileSafe(String userId, String requestingUser) {
        if (!userId.equals(requestingUser)) {
            return "Unauthorized access attempt";
        }
        // ... safe database query with parameter
        return "Authorized data for user " + userId;
    }

    // 4. Command Injection Protection: Input validation
    public String readFileSafe(String filename) {
        // Validate filename contains only alphanumeric chars, dots, underscores
        if (!Pattern.matches("^[a-zA-Z0-9._-]+$", filename)) {
            return "Invalid filename";
        }
        try {
            Process p = Runtime.getRuntime().exec(new String[]{"cat", filename});
            // ... read process output
            return "File contents";
        } catch (Exception e) {
            return "Error reading file";
        }
    }
}
